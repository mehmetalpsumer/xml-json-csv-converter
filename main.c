#define BUFFER_SIZE 256#include <stdio.h>#include <stdlib.h>#include <string.h>#include <stdbool.h>#include <libxml/parser.h>#include <unistd.h>#include <json/json.h>#include <ctype.h>// func prototypesvoid csvToXml();void xmlToCsv();void jsonToXml();void jsonToCsv();void xmlToJson();void csvToJson();void writeToCsvFile(xmlNode *node);int ftruncate(int fd, off_t length);void removeCharacters(int length, FILE *file);void jsonParseXml(json_object *j_obj, xmlNode *parent);void jsonParseCsv(json_object *j_obj, bool first_line);void writeJsonElements(xmlNode *a_node, json_object *jobj);//global variableschar input[50], output[50], format[5]; // -i -o -t varsbool input_found, format_found, output_found;bool compress = false; // compress mode for xmlFILE *csv_doc;xmlDoc *xml_doc;int main(int argc, char **argv){    //Check for arguments, if not enough then terminate    if(argc == 1)    {        printf("You haven't entered any arguments. Program will exit");        return -1;    }    //Check arguments if they match    int i;    input_found = false;    format_found = false;    output_found = false;    for(i=0; i<argc; i++){        if(strcasecmp(argv[i],"-i") == 0){            if(argc==(i+1) || (argv[i+1][0]=='-')){                printf("You put the flag '-i' but did not enter a file path. Program will exit.");                return -1;            }            else if(input_found==true){                printf("You attempted to enter multiple inputs. Program will exit.");                return -1;            }            else{                strcpy(input, argv[i+1]);                input_found = true;            }        }        else if(strcasecmp(argv[i],"-o")==0 && (argv[i+1][0]!='-')){            if(argc==i+1){                printf("You put the flag '-o' but did not enter a file path. Program will exit.");                return -1;            }            else if(output_found == true){                printf("You attempted to enter multiple outputs. Program will exit.");                return -1;            }            else{                output_found = true;                strcpy(output, argv[i+1]);            }        }        else if(strcasecmp(argv[i],"-t")==0 && (argv[i+1][0]!='-')){            if(argc==i+1){                printf("You put the flag '-t' but did not enter a format. Program will exit.");                return -1;            }            else if(format_found == true){                printf("You attempted to enter multiple formats. Program will exit.");                return -1;            }            else{                format_found = true;                strcpy(format, argv[i+1]);            }        }        else if(strcasecmp(argv[i],"-true") == 0){            compress = true;        }    }    // Check if the user entered input and format at least.    if(!(format_found && input_found)){        printf("Either input or format is missing. Program will exit.");        return -1;    }    // Get the input format from input directory    int len = strlen(input);    const char *last_four = &input[len-4];    // Determine file formats    //Convert from XML    if(strcasecmp(last_four,".xml") == 0){        if(strcasecmp(format,"csv") == 0){            xmlToCsv();        }        else if(strcasecmp(format,"json") == 0){            xmlToJson();        }    }        //Convert from CSV    else if(strcasecmp(last_four,".csv") == 0){        if(strcasecmp(format,"xml") == 0){            csvToXml();        }        else if(strcasecmp(format,"json") == 0){            csvToJson();        }    }        //Convert from JSON    else if(strcasecmp(last_four,"json") == 0){        if(strcasecmp(format,"xml") == 0){            jsonToXml();        }        else if(strcasecmp(format,"csv") == 0){            jsonToCsv();        }    }    else{        printf("Invalid input format.\n");        return -1;    }    // final info message    printf("File %s is converted from %s to %s as %s.\n",input,last_four,format,(!output_found ? "output":output));    return 0;}/* *  XML -> JSON */void xmlToJson(){    // XML Init    xmlNode *xml_root = NULL;    // JSON file root    json_object *jobj = json_object_new_object();    xml_doc = xmlReadFile(input, NULL, 0);    if (xml_doc == NULL)    {        printf("Couldn't read XML file.");    }    else    {        xml_root = xmlDocGetRootElement(xml_doc);        writeJsonElements(xml_root->children, jobj);        json_object_to_file(output,jobj);	// save file    }}void writeJsonElements(xmlNode *a_node, json_object *jobj){    xmlNode *cur_node = NULL;    char *root=NULL;    char *cur = "aa";    int a = 0;    json_object * jobj1 = json_object_new_object();    json_object * jobj2 = json_object_new_object();    json_object  *jmain = json_object_new_object();    json_object  *jarray = json_object_new_array();    // traverse xml    for (cur_node = a_node; cur_node; cur_node = cur_node->next) {        if (cur_node->type == XML_ELEMENT_NODE) {            char *tt = cur_node->children->content;            if(!isalpha(*tt) && !isdigit(*tt)){	// have children?                {                    if(a==0)                        a=1;                    else                        a=0;                }                if(a==0){                    a=1;                    {                        json_object_object_add(jobj,root ,jobj1);                    }                    jobj1 = json_object_new_object();                }                xmlAttr* attribute = cur_node->properties;	//                while(attribute && attribute->name)		// attributes adding                {                    xmlChar* value = xmlNodeListGetString(cur_node->doc, attribute->children, 1);                    json_object * jstring1 = json_object_new_string((char *)value);                    json_object_object_add(jobj1,(char *)attribute->name ,jstring1);                    attribute = attribute->next;                }                root = (char *)cur_node->name;            }            else {                if(a!=0){                    json_object * jstring = json_object_new_string(cur_node->children->content);                    if(strcmp(cur,(char *)cur_node->name)==0) // controlling for the addind array                    {                        json_object_array_add(jarray, jstring);                    }                    json_object_object_add(jobj1,cur_node->name ,jstring);                    cur = (char *)cur_node->name;                }            }        }        writeJsonElements(cur_node->children, jobj);    }}/* * JSON -> XML */void jsonToXml(){    // Initiate a xml file    xml_doc = xmlNewDoc(BAD_CAST "1.0");    xmlNode *xml_root = xmlNewNode(NULL, BAD_CAST "root");    xmlDocSetRootElement(xml_doc, xml_root);    // Read json file to a json object    json_object *j_obj = json_object_from_file(input);    // Parse the JSON file    if(j_obj != NULL)        jsonParseXml(j_obj, xml_root);    else        printf("Couldn't read JSON file.\n");     //Save the xml file    xmlSaveFormatFileEnc(output_found == true ? output:("output.xml"), xml_doc, "UTF-8", 1);    xmlFreeDoc(xml_doc);    xmlCleanupParser();    xmlMemoryDump();}void jsonParseXml(json_object *j_obj, xmlNode *parent){    json_object *j_value;    xmlNodePtr xml_parent = parent;    int j_len,i;    enum json_type type;    json_object_object_foreach(j_obj, key, val) {        type = json_object_get_type(val);        switch (type) {            case json_type_object:                xml_parent = xmlNewChild(parent, NULL, BAD_CAST key, NULL); // if it is an object, parse and store the parent                jsonParseXml(val, xml_parent);                break;            case json_type_array:                j_len = json_object_array_length(val);                // parse each element of json array and create tags for each                for (i = 0; i < j_len; i++) {                    xml_parent = xmlNewChild(parent, NULL, BAD_CAST key, NULL);                    jsonParseXml(json_object_array_get_idx(val,i), xml_parent);                }                break;            case json_type_string:                // create xml elements only if it is finally a string                // prop vs child depending on input                if (compress) {                    xmlNewProp(parent, BAD_CAST key, BAD_CAST json_object_get_string(val));                }                else {                    xmlNewChild(parent, NULL, BAD_CAST key, BAD_CAST json_object_get_string(val));                }                break;            default:                printf("Error during JSON parsing.\n");                break;        }    }}/* * JSON -> CSV */void jsonToCsv(){    // Initiate a csv file    csv_doc = fopen((output_found ? output:"output.csv"),"w");    // Read json file to a json object    json_object *j_obj = json_object_from_file(input);    jsonParseCsv(j_obj,true);    removeCharacters(1,csv_doc);    fputc('\n',csv_doc);    jsonParseCsv(j_obj,false);    removeCharacters(1,csv_doc);    fclose(csv_doc);}void jsonParseCsv(json_object *j_obj, bool first_line){    json_object *j_value;    enum json_type type;    json_object *jarray;    // json reading loop    json_object_object_foreach(j_obj,key,val){        type = json_object_get_type(val);        switch (type) {            case json_type_object:                j_value = json_object_object_get(j_obj,key);                jsonParseCsv(j_value,first_line);                break;            case json_type_array:                jarray = j_obj;                if(key) {                    jarray = json_object_object_get(j_obj, key);                }                int arraylen = json_object_array_length(jarray);                int i;                json_object * jvalue;                for (i=0; i< arraylen; i++){                    jvalue = json_object_array_get_idx(jarray, i);                    enum json_type type2;                    json_object_object_foreach(jvalue, key, val){                        if(first_line && i==0){                            fputs(key, csv_doc);                            fputc(',', csv_doc);                        }                        else if(!first_line) {                            fputs(json_object_get_string(val),csv_doc);                            fputc(',',csv_doc);                        }                    }                    removeCharacters(1,csv_doc);                    fputc('\n',csv_doc);                }                break;            default:                if (!first_line)                    fputs(json_object_get_string(val),csv_doc);                else                    fputs(key,csv_doc);                fputc(',',csv_doc);                break;        }    }}/* * XML -> CSV*/void xmlToCsv(){    // read xml file    xml_doc = xmlReadFile(input, NULL, 256); // 256 is option for parse    xmlNodePtr xml_root = NULL;    if(xml_doc == NULL){        printf("Couldn't read XML file.\n");    }    else{        // create file for csv        csv_doc = fopen((output_found ? output:"output.csv"),"w");        // init XML        xml_root = xmlDocGetRootElement(xml_doc);        xmlNode *xml_node = NULL, *xml_parent;        xml_node = xml_root->children;        // go to the first tag with text        while(xml_node->children->type!=3){            xml_node = xml_node->children;        }        xml_parent = xml_node->parent;        //write first line        while(xml_node!=NULL){            fputs(xml_node->name,csv_doc);            fputc(',',csv_doc);            xml_node = xml_node->next;        }        removeCharacters(1,csv_doc);        fputc('\n',csv_doc);        //write values        do{            writeToCsvFile(xml_parent->children);            removeCharacters(1,csv_doc);            fputc('\n',csv_doc);            xml_parent = xml_parent->next;        }while(xml_parent!=NULL);        // free memory        fclose(csv_doc);        xmlFreeDoc(xml_doc);        xmlCleanupParser();        xmlMemoryDump();    }}// write values for csvvoid writeToCsvFile(xmlNode *node){    if(node->children!=NULL){        fputs(node->children->content,csv_doc);        fputc(',',csv_doc);    }// if null element is countered put a space    else{        fputc(',',csv_doc);    }    if(node->next!=NULL)        writeToCsvFile(node->next);}/* *  CSV -> JSON */void csvToJson(){    char buf[BUFFER_SIZE]; // string to process read lines    csv_doc = fopen(input,"r"); // open and read csv file    // Is file being read successfully?    if(csv_doc == NULL){        printf("Couldn't read CSV file.\n");    }    else {        json_object *j_root = json_object_new_object();        char temp[BUFFER_SIZE]; // store first line of csv        char tags[50][50], contents[500][500]; // store tags in the xml and the contents        int row_len=0,tag_len=0,i,j=0,k=0;        strcpy(temp,fgets(buf, BUFFER_SIZE,csv_doc)); // read first line and assign to temp        // split and assign tags to tags array        for(i = 0; i<strlen(temp); i++){            if((temp[i] == ',') || (i == strlen(temp)-1)){                tag_len++;                j++;                k=0;            }            else{                tags[j][k] = temp[i];                k++;            }        }        // get content and count row length        while(feof(csv_doc)==0){            fgets(contents[row_len],BUFFER_SIZE,csv_doc);            row_len++;        }        row_len = row_len - 1;        char *token, *s=",";        json_object * j_array = json_object_new_array();        for(i=0; i<row_len; i++){            json_object * j_parent = json_object_new_object();            for(j=0; j<tag_len; j++) {                if (j == 0) { // for initiating strtok function                    token = strtok(contents[i], s);                    json_object *j_val = json_object_new_string(token);                    json_object_object_add(j_parent, tags[j], j_val);                } else {                    token = strtok(NULL, s);                    json_object *j_val = json_object_new_string(token);                    json_object_object_add(j_parent, tags[j], j_val);                }            }            json_object_array_add(j_array,j_parent);        }        json_object_object_add(j_root, "root", j_array);        fclose(csv_doc);        json_object_to_file(output,j_root);    }}/* * CSV -> XML*/void csvToXml(){    csv_doc = NULL; // csv file read from disk    char buf[BUFFER_SIZE]; // string to process read lines    csv_doc = fopen(input,"r"); // open and read csv file    // Is file being read successfully?    if(csv_doc == NULL){        printf("Couldn't read CSV file.\n");    }    else{        // Get the number of tags to be created        int tag_len=0, row_len=0,j=0,k=0,i;        char temp[BUFFER_SIZE]; // store first line of csv        char tags[50][50], contents[500][500]; // store tags in the xml and the contents        strcpy(temp,fgets(buf, BUFFER_SIZE,csv_doc)); // read first line and assign to temp        // split and assign tags to tags array        for(i = 0; i<strlen(temp); i++){            if((temp[i] == ',') || (i == strlen(temp)-1)){                tag_len++;                j++;                k=0;            }            else{                tags[j][k] = temp[i];                k++;            }        }        // get content and count row length        while(feof(csv_doc)==0){            fgets(contents[row_len],BUFFER_SIZE,csv_doc);            row_len++;        }        removeCharacters(1,csv_doc); //remove null        row_len = row_len - 1;        // Create XML file if CSV is read        xml_doc = NULL;        xmlNodePtr xml_root = NULL, xml_node = NULL, xml_parent = NULL;        // assign root and initiate XML        xml_doc = xmlNewDoc(BAD_CAST "1.0");        xml_root = xmlNewNode(NULL, BAD_CAST "root");        xmlDocSetRootElement(xml_doc, xml_root);        // create elements for XML        for(i = 0; i<row_len; i++){            xml_parent = xmlNewChild(xml_root, NULL, BAD_CAST "parent", NULL); // create a node as "parent" which doesnt exist in csv            const char s[2] = ","; // split regex            char *token; // store next split element            for(j=0; j<tag_len; j++){                if(j==0){ // for initiating strtok function                    token = strtok(contents[i], s);                    if(compress)                        xmlNewProp(xml_parent, BAD_CAST tags[j], BAD_CAST token);                    else                        xmlNewChild(xml_parent, NULL, tags[j], BAD_CAST token);                }                else{                    token = strtok(NULL, s);                    if(compress)                        xmlNewProp(xml_parent, BAD_CAST tags[j], BAD_CAST token);                    else                        xmlNewChild(xml_parent, NULL, tags[j], BAD_CAST token);                }            }        }        xmlSaveFormatFileEnc(output_found == true ? output:("output.xml"), xml_doc, "UTF-8", 1);        // free memory        fclose(csv_doc);        xmlFreeDoc(xml_doc);        xmlCleanupParser();        xmlMemoryDump();    }}// remove n character from end of file (for csv commas)void removeCharacters(int length, FILE *file){    fseeko(file,-length,SEEK_END);    int position = ftello(file);    ftruncate(fileno(file), position);}